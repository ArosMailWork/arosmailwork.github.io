---
title: Shader Graph là không đủ ? thử HLSL nhé ?
date: 2025-2-15 00:00:00 +0700
categories: [Tutorial, Shader, Vietnamese]
tags: [Tutorial, Shader, Vietnamese]
author: Sora
---

# Shader Graph là không đủ ? thử HLSL nhé ?

Lời đầu mình muốn nói trong bài blog này là cảm ơn đã bấm vào bài post đầu này, mong là nó sẽ giúp ích gì đó cho mọi người

## Shader Graph và giới hạn của nó 

Nếu mà các bạn từng mò qua về shader graph thì sẽ thấy nó rất là tiện trong việc sử dụng và thân thiện với người dùng
Tất nhiên là nó vẫn rất là đáng tin tuy nhiên nếu muốn làm 1 cái hiệu ứng gì đó nó hoành tá tràng hơn nữa như là ........ một lá bài 2 không gian chẳng hạn ?

gif here

đối với shader graph chay thì chắc là chịu chết, còn nếu dùng node custom Function thì bạn sẽ phải đào sâu hơn thế và cụ thể chính là HLSL!!!
Đây chính là cách mà bộ công cụ shader graph thường hay dùng để lấp liếm cho những thứ mà không hề code ra, tất nhiên là còn 1 cách nữa đó là sử dụng những plugin tương tự shader graph
như Amplify Shader, nhưng khi chúng ta tới với những hiệu ứng phức tạp hơn như volumetric fog thì những giới hạn tương tự cũng sẽ xảy ra
Vậy, làm cách nào để chúng ta có thể tạo được những thứ kinh khủng hơn thế ?

## Lý Thuyết
Xin giới thiệu với các độc giả, đây là HLSL (High-Level Shading Language)
thực ra Shader Graph mấy cái Node trong đó cũng đều gen ra shader code hết, cứ dòm vô doc là sẽ thấy ngay
Cấu tạo của 1 shader khi nhìn vào cũng khá là đơn giản

giờ hãy thử tạo 1 shader template tiêu chuẩn nhất bằng việc tạo 1 shader cơ bản default của unity

1. **Tạo Shader Mới**:  
   - Trong Unity, chuyển đến tab **Project** (thường ở phía dưới màn hình).  
   - Nhấp chuột phải vào thư mục **Assets** hoặc thư mục con mà bạn muốn lưu shader.  
   - Chọn **Create > Shader > Unlit Shader**.

2. **Đặt Tên Cho Shader**:  
   - Sau khi chọn xong, Unity sẽ tạo ra một file shader mới.  
   - Đặt tên file shader là `BasicShader.shader` hoặc `BasicShader`.

3. **Mở Shader Vừa Tạo**:  
   - Nhấp đúp chuột vào file `BasicShader.shader` để mở nó bằng Code IDE (Visual Studio hoặc VSCode).

4. **Cấu Trúc Shader Ban Đầu**:  
   Lúc này, code của shader sẽ trông như sau (đây là mẫu cơ bản Unity cung cấp):
   ```csharp
   Shader "Unlit/BasicShader"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
    }
    SubShader
    {
        Tags { "RenderType"="Opaque" }
        LOD 100

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            // make fog work
            #pragma multi_compile_fog

            #include "UnityCG.cginc"

            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                UNITY_FOG_COORDS(1)
                float4 vertex : SV_POSITION;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;

            v2f vert (appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);
                UNITY_TRANSFER_FOG(o,o.vertex);
                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                // sample the texture
                fixed4 col = tex2D(_MainTex, i.uv);
                // apply fog
                UNITY_APPLY_FOG(i.fogCoord, col);
                return col;
            }
            ENDCG
        }
    }
}


   ```

   Giờ hãy cùng phân tích qua cấu trúc của 1 file Shader nhé, với 1 vài quẹt xóa đi chúng ta sẽ có

   ```csharp
    Shader "Custom/BasicShader"
    {
        Properties
        {
            _MainTex ("Texture", 2D) = "white" {}
        }

        SubShader
        {
            Cull Off ZWrite Off ZTest Always    //thuộc tính ngoài có thể dùng trong shader
            LOD 200                             //thuộc tính ngoài có thể dùng trong shader

            Tags { "RenderType"="Opaque" }
            
            Pass
            {
                CGPROGRAM

                #pragma vertex vert
                #pragma fragment frag

                #include "UnityCG.cginc"

                struct appdata
                { };

                struct v2f
                { };

                sampler2D _MainTex;
                float4 _MainTex_ST;

                v2f vert (appdata v)
                {
                }

                fixed4 frag (v2f i) : SV_Target
                {
                }

                ENDCG
            }
        }

        
        Fallback "Standard"
    }
```

Đây chính là cấu trúc cơ bản của 1 file shader

- Properties: nơi show ra các giá trị view trên inspector, tùy ý, không nhất thiết phải có
- SubShader: Khu vực chứa các Pass (cái này sẽ còn được nhắc lại trong Replacement Shader)

+ Pass: Chứa các bước thực thi cho vertex shader hoặc fragment shader (surface shader không phải 1 shader lẻ, sẽ được đề cập trong 1 bài blog khác về low-level graphic programming hơn)

+ Một số thuộc tính (không có trong file gen mặc định)
> Cull Off ZWrite Off ZTest Always : 1 số thuộc tính khác liên quan tới render mặt phẳng, sẽ có blog khác về low-level graphic programming nói kĩ hơn
> LOD: Level Of Details, vượt số thì shader này sẽ được skip -> nhẹ máy

+ CGPROGRAM/ENDCG (HLSLPROGRAM/ENDHLSL): chứa code cho các phép tính toán đồ họa 
> [!NOTE]
> Lý do có 2 loại là CG với HLSL thì đây cùng là ngôn ngữ cho shader của nhà Nvidia, tuy nhiên mục đích về mặt tối ưu sẽ khác và CG là một loại đã không còn được nâng cấp nữa
> hiện tại chúng ta có HLSL sẽ mạnh hơn cho DirectX (đồ của nhà Microsoft) GLSL cho OpenGL (cái api graphic này giờ hơi đuối so với Vulkan) CG thì hỗ trợ cả 2
> HLSL có thể hỗ trợ mọi loại render pipeline của unity, còn CG thì nhịn với URP và HDRP, tuy nhiên thì migrate rất là dễ nên ko đáng lo

> [!TIP]
> HLSLINCLLUDE và CGINCLUDE có thể được sử dụng để làm gọn code thay vì tống tất cả vào CGPROGRAM/HLSLPROGRAM

> Ví dụ:
```csharp
Shader "Hidden/MyCoolCustomPostProcessingShader"
{
    HLSLINCLUDE

        #include "Packages/com.unity.postprocessing/PostProcessing/Shaders/StdLib.hlsl"

        TEXTURE2D_SAMPLER2D(_MainTex, sampler_MainTex);
        float4 _MainTex_TexelSize;
        
        struct v2f
        {
        };

        v2f Vert (AttributesDefault v)
        {
        }

        float4 Frag(v2f input) : SV_Target
        {
        }
    
    ENDHLSL
    
    SubShader
    {
        Cull Off ZWrite Off ZTest Always

        Pass
        {
            HLSLPROGRAM

                #pragma vertex Vert
                #pragma fragment Frag

            ENDHLSL
        }
    }
}
```

- Fallback: qua bước xử lý trong Pass thì tự động mò tới shader default để render

## Thực Hành
Mớ lý thuyết thế là đủ rồi, thực hành nhỉ ? Khối hộp thần kì đa chiều của chúng ta
Mình sẽ làm với built-in render pipeline của Unity cho nó độc lạ hiếm thấy (tuy built-in RP của unity khá là dở hơi khi so với những người ae sinh sau đẻ muộn nhưng chúng ta sẽ phốt nó vào 1 blog khác)

image here

Đầu tiên hãy nói về mặt ý tưởng

Khi render ra một tấm hình hay góc nhìn của camera, mỗi pixel trên màn hình sẽ chứa nhiều giá trị, trong đó có 1 cái gọi là stencil
đây là 1 shader chỉ cho phép render nếu như những pixel trên màn hình có số stencil hợp với điều kiện thì cho Pass cái shader (tức là cho xem mấy món có stencil tương ứng)
Nghe hơi lằng nhằng nhưng nói chung là giống mask effect, pixel trong vùng mask thì lộ, ngoài vùng thì giấu

đối với shader của tấm kính mask chúng ta sẽ dùng Basic Shader vừa tạo ở trên và thêm vào trong code 

```csharp
Stencil
{
    ref 1
    comp Always
    pass replace
}
```

Nó mang nghĩa là với tất cả các pixel có giá trị stencil = 1 thì nó cho pass là replace (thay thế các pixel bằng thứ được duyệt qua shader này)
vậy là ta sẽ có:

```csharp
Shader "Unlit/BasicShader"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
    }
    SubShader
    {
        Tags { "RenderType"="Opaque" }
        LOD 100

        //Phần mới thêm vào :D
        Stencil
        {
            ref 1
            comp Always
            pass replace
        }

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            // make fog work
            #pragma multi_compile_fog

            #include "UnityCG.cginc"

            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                UNITY_FOG_COORDS(1)
                float4 vertex : SV_POSITION;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;

            v2f vert (appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);
                UNITY_TRANSFER_FOG(o,o.vertex);
                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                // sample the texture
                fixed4 col = tex2D(_MainTex, i.uv);
                // apply fog
                UNITY_APPLY_FOG(i.fogCoord, col);
                return col;
            }
            ENDCG
        }
    }
}
```
Chuột phải vào file shader và **Create > Material** và gắn


Đối với những món muốn được nhìn thông qua cái mask này hãy dùng tạm cái shader standard, chúng ta có thể chèn cái này vào bất kì shader nào mình muốn, miễn là shader đó đang chưa đụng tới Stencil Buffer

**Tạo Shader Standard Mới**:  
   - Trong Unity, chuyển đến tab **Project** (thường ở phía dưới màn hình).  
   - Nhấp chuột phải vào thư mục **Assets** hoặc thư mục con mà bạn muốn lưu shader.
   - Chọn **Create > Shader > Standard Surface Shader**.
   - Đặt tên tùy ý, ở trong này mình sẽ đặt là **MaskObject**

thêm vào tương tự nhưng là

```csharp
    Stencil
    {
        ref 1
        comp equal
    }
```

Và ta sẽ có

```csharp
Shader "Custom/MaskObject"
{
    Properties
    {
        _Color ("Color", Color) = (1,1,1,1)
        _MainTex ("Albedo (RGB)", 2D) = "white" {}
        _Glossiness ("Smoothness", Range(0,1)) = 0.5
        _Metallic ("Metallic", Range(0,1)) = 0.0
    }
    SubShader
    {
        Tags { "RenderType"="Opaque" }
        LOD 200

        Stencil
        {
            ref 1
            comp equal
        }

        CGPROGRAM
        // Physically based Standard lighting model, and enable shadows on all light types
        #pragma surface surf Standard fullforwardshadows

        // Use shader model 3.0 target, to get nicer looking lighting
        #pragma target 3.0

        sampler2D _MainTex;

        struct Input
        {
            float2 uv_MainTex;
        };

        half _Glossiness;
        half _Metallic;
        fixed4 _Color;

        // Add instancing support for this shader. You need to check 'Enable Instancing' on materials that use the shader.
        // See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.
        // #pragma instancing_options assumeuniformscaling
        UNITY_INSTANCING_BUFFER_START(Props)
            // put more per-instance properties here
        UNITY_INSTANCING_BUFFER_END(Props)

        void surf (Input IN, inout SurfaceOutputStandard o)
        {
            // Albedo comes from a texture tinted by color
            fixed4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;
            o.Albedo = c.rgb;
            // Metallic and smoothness come from slider variables
            o.Metallic = _Metallic;
            o.Smoothness = _Glossiness;
            o.Alpha = c.a;
        }
        ENDCG
    }
    FallBack "Diffuse"
}

Chuột phải vào file shader và **Create > Material** và gắn rồi gắn cái Material mới tạo lên những object muốn hiển thị
Và vì mình muốn làm nhiều hơn là 1 mặt cho khối hộp này, cho nên hãy cho phép sử dụng lại giá trị này với nhiều material hơn nên hãy cho nó được quyền tinh chỉnh chút

```csharp
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
        _StencilMask("Stencil Mask", Int) = 1
    }
```

và thay Stencil Buffer bằng

```csharp
    Stencil
    {
        Ref[_StencilMask]
        comp Always
        pass replace
    }
```

Đối với các món muốn được render thông qua tấm hình cũng vậy

```csharp
    Stencil
    {
        Ref[_StencilMask]
        comp equal
    }
```

và thêm ở Properties
```csharp
Properties
    {
        _Color ("Color", Color) = (1,1,1,1)
        _MainTex ("Albedo (RGB)", 2D) = "white" {}
        _Glossiness ("Smoothness", Range(0,1)) = 0.5
        _Metallic ("Metallic", Range(0,1)) = 0.0
        _StencilMask("Stencil Mask", Int) = 1
    }
```

và giờ với setup tương tự, 2 mặt 2 materials cho mask và số stencil khác nhau và setup những đồ vật của mỗi hướng có stencil tương ứng và đây là thành quả
